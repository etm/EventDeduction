#!/usr/bin/ruby
require_relative 'lib/load'

#groups = EvDed::load_transform_classify(File.join(__dir__,'data','test.yaml'))
groups = EvDed::load_transform_classify(File.join(__dir__,'data','ronny.yaml'))

puts "Groups, sensors, number of data points and classification:"
groups.each do |k,sensors|
  puts "  #{k}"
  sensors.each do |k,series|
    puts "    #{k}: #{series.length} (#{series.classification})"
  end
end

puts "\nStep 4: ..."
groups = EvDed::align_timestamps(groups)

puts('Integrated into Step 5')


puts "\nStep 5: ..."


groups.each() {|group,sensors|
  puts "  #{group}:"
  timestamps = sensors.map() { |sensor,series|
    series.get_times()
  }.flatten().uniq()
  change_list = sensors.map() { |sensor,series|
    [sensor,{:changes => series.changes, :classification => series.classification}]
  }.to_h()

  changes_per_timestamp = {:participating_sensors => change_list.map() { |sensor_name, sensor_info| [sensor_name,1.0/sensor_info[:classification]] }.to_h(), :timestamps => {}}
  timestamps.each() { |ts|
    changes_per_timestamp[:timestamps][ts] = change_list.filter() { |name,characteristics|
      characteristics[:changes].include?(ts)
    }.keys()
  }
  puts "    sensors: #{changes_per_timestamp[:participating_sensors]}"
  puts "    changes: \n      #{changes_per_timestamp[:timestamps].map() { |k,v| "#{k}:#{v}" }.join("\n      ") }"


  max_importance = changes_per_timestamp[:participating_sensors].sum() { |sensor_name,classification| classification}
  results = []
  changes_per_timestamp[:participating_sensors].each() { |sensor,classification|
    max_importance_sensor = max_importance - changes_per_timestamp[:participating_sensors][sensor]
    x = 0.0
    changes_per_timestamp[:timestamps].each() { |timestamp,participating_sensors|
      #x += participating_sensors.include?(sensor) ? participating_sensors.sum() { |s,_| s == sensor ? 0.0 : changes_per_timestamp[:participating_sensors][s]} : max_importance_sensor - participating_sensors.sum() { |s,_| s == sensor ? 0.0 : changes_per_timestamp[:participating_sensors][s]}
      x += participating_sensors.include?(sensor) ? participating_sensors.sum() { |s,_| changes_per_timestamp[:participating_sensors][s]} : max_importance - participating_sensors.sum() { |s,_| changes_per_timestamp[:participating_sensors][s]}
    }
    #puts "    #{sensor} -> #{x} / #{max_importance_sensor*changes_per_timestamp[:timestamps].length()}"
    
    #puts "    #{sensor} -> #{x} / #{max_importance*changes_per_timestamp[:timestamps].length()}"
    results.push({:sensor => sensor, :value => x, :max_value => max_importance*changes_per_timestamp[:timestamps].length()})
  }
  pp results
  results.sort() { |x| x[:value]}.each() { |result|
    puts "    #{result[:sensor]} -> #{result[:value]} / #{result[:max_value]}"
  }

}


# pp data
